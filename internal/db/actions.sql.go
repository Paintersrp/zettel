// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: actions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addActionToNote = `-- name: AddActionToNote :exec

INSERT INTO note_actions (note_id, action_id)
VALUES ($1, $2)
ON CONFLICT (note_id, action_id) DO NOTHING
`

type AddActionToNoteParams struct {
	NoteID   int32 `json:"note_id"`
	ActionID int32 `json:"action_id"`
}

// Note Actions Queries
func (q *Queries) AddActionToNote(ctx context.Context, arg AddActionToNoteParams) error {
	_, err := q.db.Exec(ctx, addActionToNote, arg.NoteID, arg.ActionID)
	return err
}

const createAction = `-- name: CreateAction :one
INSERT INTO actions (user_id, assignee_id, title, description, priority, status, due_date)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at
`

type CreateActionParams struct {
	UserID      int32          `json:"user_id"`
	AssigneeID  int32          `json:"assignee_id"`
	Title       string         `json:"title"`
	Description pgtype.Text    `json:"description"`
	Priority    ActionPriority `json:"priority"`
	Status      ActionStatus   `json:"status"`
	DueDate     pgtype.Date    `json:"due_date"`
}

func (q *Queries) CreateAction(ctx context.Context, arg CreateActionParams) (Action, error) {
	row := q.db.QueryRow(ctx, createAction,
		arg.UserID,
		arg.AssigneeID,
		arg.Title,
		arg.Description,
		arg.Priority,
		arg.Status,
		arg.DueDate,
	)
	var i Action
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AssigneeID,
		&i.Title,
		&i.Description,
		&i.Priority,
		&i.Status,
		&i.DueDate,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAction = `-- name: DeleteAction :exec
DELETE FROM actions
WHERE id = $1 AND user_id = $2
`

type DeleteActionParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteAction(ctx context.Context, arg DeleteActionParams) error {
	_, err := q.db.Exec(ctx, deleteAction, arg.ID, arg.UserID)
	return err
}

const getAction = `-- name: GetAction :one
SELECT id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at FROM actions
WHERE id = $1 AND user_id = $2
`

type GetActionParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetAction(ctx context.Context, arg GetActionParams) (Action, error) {
	row := q.db.QueryRow(ctx, getAction, arg.ID, arg.UserID)
	var i Action
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AssigneeID,
		&i.Title,
		&i.Description,
		&i.Priority,
		&i.Status,
		&i.DueDate,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActionCompletionStats = `-- name: GetActionCompletionStats :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'done') AS completed_count,
    COUNT(*) FILTER (WHERE status != 'done') AS pending_count,
    AVG(EXTRACT(EPOCH FROM (completed_at - created_at)) / 3600)::float AS avg_completion_time_hours
FROM actions
WHERE user_id = $1 AND created_at >= CURRENT_DATE - INTERVAL '30 days'
`

type GetActionCompletionStatsRow struct {
	CompletedCount         int64   `json:"completed_count"`
	PendingCount           int64   `json:"pending_count"`
	AvgCompletionTimeHours float64 `json:"avg_completion_time_hours"`
}

func (q *Queries) GetActionCompletionStats(ctx context.Context, userID int32) (GetActionCompletionStatsRow, error) {
	row := q.db.QueryRow(ctx, getActionCompletionStats, userID)
	var i GetActionCompletionStatsRow
	err := row.Scan(&i.CompletedCount, &i.PendingCount, &i.AvgCompletionTimeHours)
	return i, err
}

const getActionsByPriority = `-- name: GetActionsByPriority :many
SELECT id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at FROM actions
WHERE user_id = $1 AND priority = $2
ORDER BY due_date ASC NULLS LAST, created_at DESC
LIMIT $3 OFFSET $4
`

type GetActionsByPriorityParams struct {
	UserID   int32          `json:"user_id"`
	Priority ActionPriority `json:"priority"`
	Limit    int32          `json:"limit"`
	Offset   int32          `json:"offset"`
}

func (q *Queries) GetActionsByPriority(ctx context.Context, arg GetActionsByPriorityParams) ([]Action, error) {
	rows, err := q.db.Query(ctx, getActionsByPriority,
		arg.UserID,
		arg.Priority,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Action
	for rows.Next() {
		var i Action
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.DueDate,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActionsByStatus = `-- name: GetActionsByStatus :many
SELECT id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at FROM actions
WHERE user_id = $1 AND status = $2
ORDER BY due_date ASC NULLS LAST, created_at DESC
LIMIT $3 OFFSET $4
`

type GetActionsByStatusParams struct {
	UserID int32        `json:"user_id"`
	Status ActionStatus `json:"status"`
	Limit  int32        `json:"limit"`
	Offset int32        `json:"offset"`
}

func (q *Queries) GetActionsByStatus(ctx context.Context, arg GetActionsByStatusParams) ([]Action, error) {
	rows, err := q.db.Query(ctx, getActionsByStatus,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Action
	for rows.Next() {
		var i Action
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.DueDate,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActionsForNote = `-- name: GetActionsForNote :many
SELECT a.id, a.user_id, a.assignee_id, a.title, a.description, a.priority, a.status, a.due_date, a.completed_at, a.created_at, a.updated_at FROM actions a
JOIN note_actions na ON a.id = na.action_id
WHERE na.note_id = $1
ORDER BY a.due_date ASC NULLS LAST, a.created_at DESC
`

func (q *Queries) GetActionsForNote(ctx context.Context, noteID int32) ([]Action, error) {
	rows, err := q.db.Query(ctx, getActionsForNote, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Action
	for rows.Next() {
		var i Action
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.DueDate,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostActiveNotes = `-- name: GetMostActiveNotes :many
SELECT n.id, n.title, COUNT(na.action_id) AS action_count
FROM notes n
JOIN note_actions na ON n.id = na.note_id
WHERE n.user_id = $1
GROUP BY n.id, n.title
ORDER BY action_count DESC
LIMIT $2
`

type GetMostActiveNotesParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

type GetMostActiveNotesRow struct {
	ID          int32  `json:"id"`
	Title       string `json:"title"`
	ActionCount int64  `json:"action_count"`
}

func (q *Queries) GetMostActiveNotes(ctx context.Context, arg GetMostActiveNotesParams) ([]GetMostActiveNotesRow, error) {
	rows, err := q.db.Query(ctx, getMostActiveNotes, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostActiveNotesRow
	for rows.Next() {
		var i GetMostActiveNotesRow
		if err := rows.Scan(&i.ID, &i.Title, &i.ActionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotesForAction = `-- name: GetNotesForAction :many
SELECT n.id, n.user_id, n.title, n.content, n.content_vector, n.created_at, n.updated_at FROM notes n
JOIN note_actions na ON n.id = na.note_id
WHERE na.action_id = $1
ORDER BY n.updated_at DESC
`

func (q *Queries) GetNotesForAction(ctx context.Context, actionID int32) ([]Note, error) {
	rows, err := q.db.Query(ctx, getNotesForAction, actionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.ContentVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverdueActions = `-- name: GetOverdueActions :many
SELECT id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at FROM actions
WHERE user_id = $1 AND due_date < CURRENT_DATE AND status != 'done'
ORDER BY due_date ASC
`

func (q *Queries) GetOverdueActions(ctx context.Context, userID int32) ([]Action, error) {
	rows, err := q.db.Query(ctx, getOverdueActions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Action
	for rows.Next() {
		var i Action
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.DueDate,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingActions = `-- name: GetUpcomingActions :many
SELECT id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at FROM actions
WHERE user_id = $1 
  AND due_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '7 days'
  AND status != 'done'
ORDER BY due_date ASC
`

func (q *Queries) GetUpcomingActions(ctx context.Context, userID int32) ([]Action, error) {
	rows, err := q.db.Query(ctx, getUpcomingActions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Action
	for rows.Next() {
		var i Action
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.DueDate,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByAssignee = `-- name: ListActionsByAssignee :many
SELECT id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at FROM actions
WHERE assignee_id = $1
ORDER BY due_date ASC NULLS LAST, created_at DESC
LIMIT $2 OFFSET $3
`

type ListActionsByAssigneeParams struct {
	AssigneeID int32 `json:"assignee_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListActionsByAssignee(ctx context.Context, arg ListActionsByAssigneeParams) ([]Action, error) {
	rows, err := q.db.Query(ctx, listActionsByAssignee, arg.AssigneeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Action
	for rows.Next() {
		var i Action
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.DueDate,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByUser = `-- name: ListActionsByUser :many
SELECT id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at FROM actions
WHERE user_id = $1
ORDER BY due_date ASC NULLS LAST, created_at DESC
LIMIT $2 OFFSET $3
`

type ListActionsByUserParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListActionsByUser(ctx context.Context, arg ListActionsByUserParams) ([]Action, error) {
	rows, err := q.db.Query(ctx, listActionsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Action
	for rows.Next() {
		var i Action
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.DueDate,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsWithNoteCount = `-- name: ListActionsWithNoteCount :many
SELECT a.id, a.user_id, a.assignee_id, a.title, a.description, a.priority, a.status, a.due_date, a.completed_at, a.created_at, a.updated_at, COUNT(na.note_id) AS note_count
FROM actions a
LEFT JOIN note_actions na ON a.id = na.action_id
WHERE a.user_id = $1
GROUP BY a.id
ORDER BY a.due_date ASC NULLS LAST, a.created_at DESC
LIMIT $2 OFFSET $3
`

type ListActionsWithNoteCountParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListActionsWithNoteCountRow struct {
	ID          int32              `json:"id"`
	UserID      int32              `json:"user_id"`
	AssigneeID  int32              `json:"assignee_id"`
	Title       string             `json:"title"`
	Description pgtype.Text        `json:"description"`
	Priority    ActionPriority     `json:"priority"`
	Status      ActionStatus       `json:"status"`
	DueDate     pgtype.Date        `json:"due_date"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	NoteCount   int64              `json:"note_count"`
}

func (q *Queries) ListActionsWithNoteCount(ctx context.Context, arg ListActionsWithNoteCountParams) ([]ListActionsWithNoteCountRow, error) {
	rows, err := q.db.Query(ctx, listActionsWithNoteCount, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActionsWithNoteCountRow
	for rows.Next() {
		var i ListActionsWithNoteCountRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.DueDate,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeActionFromNote = `-- name: RemoveActionFromNote :exec
DELETE FROM note_actions
WHERE note_id = $1 AND action_id = $2
`

type RemoveActionFromNoteParams struct {
	NoteID   int32 `json:"note_id"`
	ActionID int32 `json:"action_id"`
}

func (q *Queries) RemoveActionFromNote(ctx context.Context, arg RemoveActionFromNoteParams) error {
	_, err := q.db.Exec(ctx, removeActionFromNote, arg.NoteID, arg.ActionID)
	return err
}

const searchActions = `-- name: SearchActions :many
SELECT id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at FROM actions
WHERE user_id = $1
  AND (title ILIKE '%' || $2 || '%' OR description ILIKE '%' || $2 || '%')
ORDER BY due_date ASC NULLS LAST, created_at DESC
LIMIT $3 OFFSET $4
`

type SearchActionsParams struct {
	UserID  int32       `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchActions(ctx context.Context, arg SearchActionsParams) ([]Action, error) {
	rows, err := q.db.Query(ctx, searchActions,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Action
	for rows.Next() {
		var i Action
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.DueDate,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAction = `-- name: UpdateAction :one
UPDATE actions
SET assignee_id = $2,
    title = $3,
    description = $4,
    priority = $5,
    status = $6,
    due_date = $7,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND user_id = $8
RETURNING id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at
`

type UpdateActionParams struct {
	ID          int32          `json:"id"`
	AssigneeID  int32          `json:"assignee_id"`
	Title       string         `json:"title"`
	Description pgtype.Text    `json:"description"`
	Priority    ActionPriority `json:"priority"`
	Status      ActionStatus   `json:"status"`
	DueDate     pgtype.Date    `json:"due_date"`
	UserID      int32          `json:"user_id"`
}

func (q *Queries) UpdateAction(ctx context.Context, arg UpdateActionParams) (Action, error) {
	row := q.db.QueryRow(ctx, updateAction,
		arg.ID,
		arg.AssigneeID,
		arg.Title,
		arg.Description,
		arg.Priority,
		arg.Status,
		arg.DueDate,
		arg.UserID,
	)
	var i Action
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AssigneeID,
		&i.Title,
		&i.Description,
		&i.Priority,
		&i.Status,
		&i.DueDate,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateActionStatus = `-- name: UpdateActionStatus :one
UPDATE actions
SET status = $2, 
    completed_at = CASE WHEN $2 = 'done' THEN CURRENT_TIMESTAMP ELSE NULL END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND user_id = $3
RETURNING id, user_id, assignee_id, title, description, priority, status, due_date, completed_at, created_at, updated_at
`

type UpdateActionStatusParams struct {
	ID     int32        `json:"id"`
	Status ActionStatus `json:"status"`
	UserID int32        `json:"user_id"`
}

func (q *Queries) UpdateActionStatus(ctx context.Context, arg UpdateActionStatusParams) (Action, error) {
	row := q.db.QueryRow(ctx, updateActionStatus, arg.ID, arg.Status, arg.UserID)
	var i Action
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AssigneeID,
		&i.Title,
		&i.Description,
		&i.Priority,
		&i.Status,
		&i.DueDate,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
