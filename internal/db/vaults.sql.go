// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: vaults.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVault = `-- name: CreateVault :one
INSERT INTO vaults (name, user_id, commit, description)
VALUES ($1, $2, $3, $4)
RETURNING id, name, user_id, commit, created_at, updated_at, description
`

type CreateVaultParams struct {
	Name        string      `json:"name"`
	UserID      pgtype.Int4 `json:"user_id"`
	Commit      pgtype.Text `json:"commit"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateVault(ctx context.Context, arg CreateVaultParams) (Vault, error) {
	row := q.db.QueryRow(ctx, createVault,
		arg.Name,
		arg.UserID,
		arg.Commit,
		arg.Description,
	)
	var i Vault
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.Commit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
	)
	return i, err
}

const deleteVault = `-- name: DeleteVault :exec
DELETE FROM vaults
WHERE id = $1
`

func (q *Queries) DeleteVault(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteVault, id)
	return err
}

const getNoteCount = `-- name: GetNoteCount :one
SELECT 
    COUNT(*) AS note_count
FROM 
    notes
WHERE 
    vault_id = $1
    AND ($2::boolean IS NOT TRUE OR (
        SELECT COUNT(*) 
        FROM note_links nl 
        WHERE nl.note_id = notes.id
    ) = 0)
    AND ($3::boolean IS NOT TRUE OR (
        SELECT COUNT(*) 
        FROM note_tags nt 
        WHERE nt.note_id = notes.id
    ) = 0)
`

type GetNoteCountParams struct {
	VaultID pgtype.Int4 `json:"vault_id"`
	Column2 bool        `json:"column_2"`
	Column3 bool        `json:"column_3"`
}

func (q *Queries) GetNoteCount(ctx context.Context, arg GetNoteCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getNoteCount, arg.VaultID, arg.Column2, arg.Column3)
	var note_count int64
	err := row.Scan(&note_count)
	return note_count, err
}

const getPaginatedNotes = `-- name: GetPaginatedNotes :many
WITH paginated_notes AS (
    SELECT 
        n.id,
        n.title,
        n.user_id,
        n.vault_id,
        n.upstream,
        n.content,
        n.created_at,
        n.updated_at,
        row_number() OVER (ORDER BY n.created_at DESC) AS row_num
    FROM 
        notes n
    WHERE 
        n.vault_id = $1
        AND ($4::boolean IS NOT TRUE OR (
            SELECT COUNT(*) 
            FROM note_links nl 
            WHERE nl.note_id = n.id
        ) = 0)
        AND ($5::boolean IS NOT TRUE OR (
            SELECT COUNT(*) 
            FROM note_tags nt 
            WHERE nt.note_id = n.id
        ) = 0)
)
SELECT 
    pn.id,
    pn.title,
    pn.user_id,
    pn.vault_id,
    pn.upstream,
    pn.content,
    pn.created_at,
    pn.updated_at,
    COALESCE(JSON_AGG(tags.tag_info) FILTER (WHERE tags.tag_info IS NOT NULL), '[]'::json) AS tags,
    COALESCE(JSON_AGG(linked_notes.linked_note_info) FILTER (WHERE linked_notes.linked_note_info IS NOT NULL), '[]'::json) AS linked_notes
FROM 
    paginated_notes pn
LEFT JOIN (
    SELECT 
        nt.note_id,
        JSON_BUILD_OBJECT('id', t.id, 'name', t.name) AS tag_info
    FROM 
        note_tags nt
    LEFT JOIN 
        tags t ON nt.tag_id = t.id
) tags ON pn.id = tags.note_id
LEFT JOIN (
    SELECT 
        nl.note_id,
        JSON_BUILD_OBJECT('id', ln.id, 'title', ln.title) AS linked_note_info
    FROM 
        note_links nl
    LEFT JOIN 
        notes ln ON nl.linked_note_id = ln.id
) linked_notes ON pn.id = linked_notes.note_id
WHERE 
    pn.row_num BETWEEN ($2::int * $3::int) + 1 AND (($2::int + 1) * $3::int)
GROUP BY
    pn.id, pn.title, pn.user_id, pn.vault_id, pn.upstream, pn.content, pn.created_at, pn.updated_at
ORDER BY 
    pn.created_at DESC
`

type GetPaginatedNotesParams struct {
	VaultID pgtype.Int4 `json:"vault_id"`
	Column2 int32       `json:"column_2"`
	Column3 int32       `json:"column_3"`
	Column4 bool        `json:"column_4"`
	Column5 bool        `json:"column_5"`
}

type GetPaginatedNotesRow struct {
	ID          int32              `json:"id"`
	Title       string             `json:"title"`
	UserID      pgtype.Int4        `json:"user_id"`
	VaultID     pgtype.Int4        `json:"vault_id"`
	Upstream    pgtype.Int4        `json:"upstream"`
	Content     string             `json:"content"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Tags        interface{}        `json:"tags"`
	LinkedNotes interface{}        `json:"linked_notes"`
}

func (q *Queries) GetPaginatedNotes(ctx context.Context, arg GetPaginatedNotesParams) ([]GetPaginatedNotesRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedNotes,
		arg.VaultID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedNotesRow
	for rows.Next() {
		var i GetPaginatedNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.UserID,
			&i.VaultID,
			&i.Upstream,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
			&i.LinkedNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVault = `-- name: GetVault :one
SELECT
    v.id,
    v.name,
    v.user_id,
    v.commit,
    v.created_at,
    v.updated_at,
    v.description
FROM vaults v
WHERE v.id = $1
`

func (q *Queries) GetVault(ctx context.Context, id int32) (Vault, error) {
	row := q.db.QueryRow(ctx, getVault, id)
	var i Vault
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.Commit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
	)
	return i, err
}

const getVaultsByUser = `-- name: GetVaultsByUser :many
SELECT 
    v.id,
    v.name,
    v.user_id,
    v.commit,
    v.created_at,
    v.updated_at,
    v.description,
    COALESCE(json_agg(json_build_object(
        'id', n.id,
        'title', n.title,
        'user_id', n.user_id,
        'vault_id', n.vault_id,
        'upstream', n.upstream,
        'content', n.content,
        'created_at', n.created_at,
        'updated_at', n.updated_at
    )) FILTER (WHERE n.id IS NOT NULL), '[]') AS notes
FROM vaults v
LEFT JOIN notes n ON v.id = n.vault_id
WHERE v.user_id = $1
GROUP BY v.id
ORDER BY v.created_at DESC
`

type GetVaultsByUserRow struct {
	ID          int32              `json:"id"`
	Name        string             `json:"name"`
	UserID      pgtype.Int4        `json:"user_id"`
	Commit      pgtype.Text        `json:"commit"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Description pgtype.Text        `json:"description"`
	Notes       interface{}        `json:"notes"`
}

func (q *Queries) GetVaultsByUser(ctx context.Context, userID pgtype.Int4) ([]GetVaultsByUserRow, error) {
	rows, err := q.db.Query(ctx, getVaultsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVaultsByUserRow
	for rows.Next() {
		var i GetVaultsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.Commit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVaultsByUserLite = `-- name: GetVaultsByUserLite :many
SELECT 
    v.id,
    v.name,
    v.user_id,
    v.commit,
    v.created_at,
    v.updated_at,
    v.description
FROM vaults v
WHERE v.user_id = $1
ORDER BY v.created_at DESC
`

func (q *Queries) GetVaultsByUserLite(ctx context.Context, userID pgtype.Int4) ([]Vault, error) {
	rows, err := q.db.Query(ctx, getVaultsByUserLite, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vault
	for rows.Next() {
		var i Vault
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.Commit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasMoreNotes = `-- name: HasMoreNotes :one
SELECT COUNT(*) > ($2 + $3) AS has_more
FROM notes
WHERE vault_id = $1
`

type HasMoreNotesParams struct {
	VaultID pgtype.Int4 `json:"vault_id"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
}

func (q *Queries) HasMoreNotes(ctx context.Context, arg HasMoreNotesParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasMoreNotes, arg.VaultID, arg.Column2, arg.Column3)
	var has_more bool
	err := row.Scan(&has_more)
	return has_more, err
}

const updateVault = `-- name: UpdateVault :one
UPDATE vaults
SET name = $2, commit = $3, description = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, user_id, commit, created_at, updated_at, description
`

type UpdateVaultParams struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Commit      pgtype.Text `json:"commit"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateVault(ctx context.Context, arg UpdateVaultParams) (Vault, error) {
	row := q.db.QueryRow(ctx, updateVault,
		arg.ID,
		arg.Name,
		arg.Commit,
		arg.Description,
	)
	var i Vault
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.Commit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
	)
	return i, err
}
