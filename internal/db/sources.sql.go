// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: sources.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addSourceToNote = `-- name: AddSourceToNote :exec

INSERT INTO note_sources (note_id, source_id)
VALUES ($1, $2)
ON CONFLICT (note_id, source_id) DO NOTHING
`

type AddSourceToNoteParams struct {
	NoteID   int32 `json:"note_id"`
	SourceID int32 `json:"source_id"`
}

// Note Sources Queries
func (q *Queries) AddSourceToNote(ctx context.Context, arg AddSourceToNoteParams) error {
	_, err := q.db.Exec(ctx, addSourceToNote, arg.NoteID, arg.SourceID)
	return err
}

const createSource = `-- name: CreateSource :one
INSERT INTO sources (user_id, title, url, author, publication_date, content)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, title, url, author, publication_date, content, created_at, updated_at
`

type CreateSourceParams struct {
	UserID          int32       `json:"user_id"`
	Title           string      `json:"title"`
	Url             pgtype.Text `json:"url"`
	Author          pgtype.Text `json:"author"`
	PublicationDate pgtype.Date `json:"publication_date"`
	Content         pgtype.Text `json:"content"`
}

func (q *Queries) CreateSource(ctx context.Context, arg CreateSourceParams) (Source, error) {
	row := q.db.QueryRow(ctx, createSource,
		arg.UserID,
		arg.Title,
		arg.Url,
		arg.Author,
		arg.PublicationDate,
		arg.Content,
	)
	var i Source
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Url,
		&i.Author,
		&i.PublicationDate,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSource = `-- name: DeleteSource :exec
DELETE FROM sources
WHERE id = $1 AND user_id = $2
`

type DeleteSourceParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteSource(ctx context.Context, arg DeleteSourceParams) error {
	_, err := q.db.Exec(ctx, deleteSource, arg.ID, arg.UserID)
	return err
}

const getMostReferencedSources = `-- name: GetMostReferencedSources :many

SELECT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at, COUNT(ns.note_id) AS reference_count
FROM sources s
JOIN note_sources ns ON s.id = ns.source_id
WHERE s.user_id = $1
GROUP BY s.id
ORDER BY reference_count DESC
LIMIT $2
`

type GetMostReferencedSourcesParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

type GetMostReferencedSourcesRow struct {
	ID              int32              `json:"id"`
	UserID          int32              `json:"user_id"`
	Title           string             `json:"title"`
	Url             pgtype.Text        `json:"url"`
	Author          pgtype.Text        `json:"author"`
	PublicationDate pgtype.Date        `json:"publication_date"`
	Content         pgtype.Text        `json:"content"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ReferenceCount  int64              `json:"reference_count"`
}

// Other Queries
func (q *Queries) GetMostReferencedSources(ctx context.Context, arg GetMostReferencedSourcesParams) ([]GetMostReferencedSourcesRow, error) {
	rows, err := q.db.Query(ctx, getMostReferencedSources, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostReferencedSourcesRow
	for rows.Next() {
		var i GetMostReferencedSourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReferenceCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotesForSource = `-- name: GetNotesForSource :many
SELECT n.id, n.user_id, n.title, n.content, n.content_vector, n.created_at, n.updated_at
FROM notes n
JOIN note_sources ns ON n.id = ns.note_id
WHERE ns.source_id = $1
ORDER BY n.updated_at DESC
`

func (q *Queries) GetNotesForSource(ctx context.Context, sourceID int32) ([]Note, error) {
	rows, err := q.db.Query(ctx, getNotesForSource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.ContentVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentlyAddedSourcesWithNotes = `-- name: GetRecentlyAddedSourcesWithNotes :many
SELECT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at, 
       json_agg(json_build_object('id', n.id, 'title', n.title)) AS linked_notes
FROM sources s
JOIN note_sources ns ON s.id = ns.source_id
JOIN notes n ON ns.note_id = n.id
WHERE s.user_id = $1
  AND s.created_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY s.id
ORDER BY s.created_at DESC
LIMIT $2
`

type GetRecentlyAddedSourcesWithNotesParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

type GetRecentlyAddedSourcesWithNotesRow struct {
	ID              int32              `json:"id"`
	UserID          int32              `json:"user_id"`
	Title           string             `json:"title"`
	Url             pgtype.Text        `json:"url"`
	Author          pgtype.Text        `json:"author"`
	PublicationDate pgtype.Date        `json:"publication_date"`
	Content         pgtype.Text        `json:"content"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	LinkedNotes     []byte             `json:"linked_notes"`
}

func (q *Queries) GetRecentlyAddedSourcesWithNotes(ctx context.Context, arg GetRecentlyAddedSourcesWithNotesParams) ([]GetRecentlyAddedSourcesWithNotesRow, error) {
	rows, err := q.db.Query(ctx, getRecentlyAddedSourcesWithNotes, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentlyAddedSourcesWithNotesRow
	for rows.Next() {
		var i GetRecentlyAddedSourcesWithNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LinkedNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSource = `-- name: GetSource :one
SELECT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at, 
       (SELECT COUNT(*) FROM note_sources WHERE source_id = s.id) AS note_count
FROM sources s
WHERE s.id = $1 AND s.user_id = $2
`

type GetSourceParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

type GetSourceRow struct {
	ID              int32              `json:"id"`
	UserID          int32              `json:"user_id"`
	Title           string             `json:"title"`
	Url             pgtype.Text        `json:"url"`
	Author          pgtype.Text        `json:"author"`
	PublicationDate pgtype.Date        `json:"publication_date"`
	Content         pgtype.Text        `json:"content"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	NoteCount       int64              `json:"note_count"`
}

func (q *Queries) GetSource(ctx context.Context, arg GetSourceParams) (GetSourceRow, error) {
	row := q.db.QueryRow(ctx, getSource, arg.ID, arg.UserID)
	var i GetSourceRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Url,
		&i.Author,
		&i.PublicationDate,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NoteCount,
	)
	return i, err
}

const getSourcesByDateRange = `-- name: GetSourcesByDateRange :many
SELECT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at, 
       (SELECT COUNT(*) FROM note_sources WHERE source_id = s.id) AS note_count
FROM sources s
WHERE s.user_id = $1
  AND s.publication_date BETWEEN $2 AND $3
ORDER BY s.publication_date DESC
LIMIT $4 OFFSET $5
`

type GetSourcesByDateRangeParams struct {
	UserID            int32       `json:"user_id"`
	PublicationDate   pgtype.Date `json:"publication_date"`
	PublicationDate_2 pgtype.Date `json:"publication_date_2"`
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
}

type GetSourcesByDateRangeRow struct {
	ID              int32              `json:"id"`
	UserID          int32              `json:"user_id"`
	Title           string             `json:"title"`
	Url             pgtype.Text        `json:"url"`
	Author          pgtype.Text        `json:"author"`
	PublicationDate pgtype.Date        `json:"publication_date"`
	Content         pgtype.Text        `json:"content"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	NoteCount       int64              `json:"note_count"`
}

func (q *Queries) GetSourcesByDateRange(ctx context.Context, arg GetSourcesByDateRangeParams) ([]GetSourcesByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getSourcesByDateRange,
		arg.UserID,
		arg.PublicationDate,
		arg.PublicationDate_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSourcesByDateRangeRow
	for rows.Next() {
		var i GetSourcesByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSourcesForNote = `-- name: GetSourcesForNote :many
SELECT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at
FROM sources s
JOIN note_sources ns ON s.id = ns.source_id
WHERE ns.note_id = $1
ORDER BY s.created_at DESC
`

func (q *Queries) GetSourcesForNote(ctx context.Context, noteID int32) ([]Source, error) {
	rows, err := q.db.Query(ctx, getSourcesForNote, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Source
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSourcesWithSimilarTitles = `-- name: GetSourcesWithSimilarTitles :many
SELECT s1.id, s1.user_id, s1.title, s1.url, s1.author, s1.publication_date, s1.content, s1.created_at, s1.updated_at, 
       s2.id AS similar_id, 
       s2.title AS similar_title,
       similarity(s1.title, s2.title) AS title_similarity
FROM sources s1
JOIN sources s2 ON s1.id < s2.id
WHERE s1.user_id = $1 AND s2.user_id = $1
  AND similarity(s1.title, s2.title) > 0.6
ORDER BY title_similarity DESC
LIMIT $2
`

type GetSourcesWithSimilarTitlesParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

type GetSourcesWithSimilarTitlesRow struct {
	ID              int32              `json:"id"`
	UserID          int32              `json:"user_id"`
	Title           string             `json:"title"`
	Url             pgtype.Text        `json:"url"`
	Author          pgtype.Text        `json:"author"`
	PublicationDate pgtype.Date        `json:"publication_date"`
	Content         pgtype.Text        `json:"content"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	SimilarID       int32              `json:"similar_id"`
	SimilarTitle    string             `json:"similar_title"`
	TitleSimilarity interface{}        `json:"title_similarity"`
}

func (q *Queries) GetSourcesWithSimilarTitles(ctx context.Context, arg GetSourcesWithSimilarTitlesParams) ([]GetSourcesWithSimilarTitlesRow, error) {
	rows, err := q.db.Query(ctx, getSourcesWithSimilarTitles, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSourcesWithSimilarTitlesRow
	for rows.Next() {
		var i GetSourcesWithSimilarTitlesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SimilarID,
			&i.SimilarTitle,
			&i.TitleSimilarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreferencedSources = `-- name: GetUnreferencedSources :many
SELECT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at
FROM sources s
LEFT JOIN note_sources ns ON s.id = ns.source_id
WHERE s.user_id = $1 AND ns.source_id IS NULL
ORDER BY s.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUnreferencedSourcesParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetUnreferencedSources(ctx context.Context, arg GetUnreferencedSourcesParams) ([]Source, error) {
	rows, err := q.db.Query(ctx, getUnreferencedSources, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Source
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSources = `-- name: ListSources :many
SELECT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at, 
       (SELECT COUNT(*) FROM note_sources WHERE source_id = s.id) AS note_count
FROM sources s
WHERE s.user_id = $1
ORDER BY s.created_at DESC
LIMIT $2 OFFSET $3
`

type ListSourcesParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSourcesRow struct {
	ID              int32              `json:"id"`
	UserID          int32              `json:"user_id"`
	Title           string             `json:"title"`
	Url             pgtype.Text        `json:"url"`
	Author          pgtype.Text        `json:"author"`
	PublicationDate pgtype.Date        `json:"publication_date"`
	Content         pgtype.Text        `json:"content"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	NoteCount       int64              `json:"note_count"`
}

func (q *Queries) ListSources(ctx context.Context, arg ListSourcesParams) ([]ListSourcesRow, error) {
	rows, err := q.db.Query(ctx, listSources, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSourcesRow
	for rows.Next() {
		var i ListSourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourcesWithNoteCounts = `-- name: ListSourcesWithNoteCounts :many
SELECT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at, COUNT(ns.note_id) AS note_count
FROM sources s
LEFT JOIN note_sources ns ON s.id = ns.source_id
WHERE s.user_id = $1
GROUP BY s.id
ORDER BY s.created_at DESC
LIMIT $2 OFFSET $3
`

type ListSourcesWithNoteCountsParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSourcesWithNoteCountsRow struct {
	ID              int32              `json:"id"`
	UserID          int32              `json:"user_id"`
	Title           string             `json:"title"`
	Url             pgtype.Text        `json:"url"`
	Author          pgtype.Text        `json:"author"`
	PublicationDate pgtype.Date        `json:"publication_date"`
	Content         pgtype.Text        `json:"content"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	NoteCount       int64              `json:"note_count"`
}

func (q *Queries) ListSourcesWithNoteCounts(ctx context.Context, arg ListSourcesWithNoteCountsParams) ([]ListSourcesWithNoteCountsRow, error) {
	rows, err := q.db.Query(ctx, listSourcesWithNoteCounts, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSourcesWithNoteCountsRow
	for rows.Next() {
		var i ListSourcesWithNoteCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeSourceFromNote = `-- name: RemoveSourceFromNote :exec
DELETE FROM note_sources
WHERE note_id = $1 AND source_id = $2
`

type RemoveSourceFromNoteParams struct {
	NoteID   int32 `json:"note_id"`
	SourceID int32 `json:"source_id"`
}

func (q *Queries) RemoveSourceFromNote(ctx context.Context, arg RemoveSourceFromNoteParams) error {
	_, err := q.db.Exec(ctx, removeSourceFromNote, arg.NoteID, arg.SourceID)
	return err
}

const searchSources = `-- name: SearchSources :many
SELECT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at, 
       (SELECT COUNT(*) FROM note_sources WHERE source_id = s.id) AS note_count
FROM sources s
WHERE s.user_id = $1
  AND (s.title ILIKE '%' || $2 || '%' 
       OR s.author ILIKE '%' || $2 || '%' 
       OR s.content ILIKE '%' || $2 || '%')
ORDER BY s.created_at DESC
LIMIT $3 OFFSET $4
`

type SearchSourcesParams struct {
	UserID  int32       `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchSourcesRow struct {
	ID              int32              `json:"id"`
	UserID          int32              `json:"user_id"`
	Title           string             `json:"title"`
	Url             pgtype.Text        `json:"url"`
	Author          pgtype.Text        `json:"author"`
	PublicationDate pgtype.Date        `json:"publication_date"`
	Content         pgtype.Text        `json:"content"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	NoteCount       int64              `json:"note_count"`
}

func (q *Queries) SearchSources(ctx context.Context, arg SearchSourcesParams) ([]SearchSourcesRow, error) {
	rows, err := q.db.Query(ctx, searchSources,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSourcesRow
	for rows.Next() {
		var i SearchSourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSourcesFullText = `-- name: SearchSourcesFullText :many
SELECT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at, 
       ts_rank(to_tsvector('english', s.title || ' ' || COALESCE(s.author, '') || ' ' || COALESCE(s.content, '')), query) AS rank
FROM sources s, to_tsquery('english', $2) query
WHERE s.user_id = $1
  AND to_tsvector('english', s.title || ' ' || COALESCE(s.author, '') || ' ' || COALESCE(s.content, '')) @@ query
ORDER BY rank DESC
LIMIT $3 OFFSET $4
`

type SearchSourcesFullTextParams struct {
	UserID    int32  `json:"user_id"`
	ToTsquery string `json:"to_tsquery"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

type SearchSourcesFullTextRow struct {
	ID              int32              `json:"id"`
	UserID          int32              `json:"user_id"`
	Title           string             `json:"title"`
	Url             pgtype.Text        `json:"url"`
	Author          pgtype.Text        `json:"author"`
	PublicationDate pgtype.Date        `json:"publication_date"`
	Content         pgtype.Text        `json:"content"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	Rank            float32            `json:"rank"`
}

func (q *Queries) SearchSourcesFullText(ctx context.Context, arg SearchSourcesFullTextParams) ([]SearchSourcesFullTextRow, error) {
	rows, err := q.db.Query(ctx, searchSourcesFullText,
		arg.UserID,
		arg.ToTsquery,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSourcesFullTextRow
	for rows.Next() {
		var i SearchSourcesFullTextRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSource = `-- name: UpdateSource :one
UPDATE sources
SET title = $2, url = $3, author = $4, publication_date = $5, content = $6, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND user_id = $7
RETURNING id, user_id, title, url, author, publication_date, content, created_at, updated_at
`

type UpdateSourceParams struct {
	ID              int32       `json:"id"`
	Title           string      `json:"title"`
	Url             pgtype.Text `json:"url"`
	Author          pgtype.Text `json:"author"`
	PublicationDate pgtype.Date `json:"publication_date"`
	Content         pgtype.Text `json:"content"`
	UserID          int32       `json:"user_id"`
}

func (q *Queries) UpdateSource(ctx context.Context, arg UpdateSourceParams) (Source, error) {
	row := q.db.QueryRow(ctx, updateSource,
		arg.ID,
		arg.Title,
		arg.Url,
		arg.Author,
		arg.PublicationDate,
		arg.Content,
		arg.UserID,
	)
	var i Source
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Url,
		&i.Author,
		&i.PublicationDate,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
