// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: hubs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addHubCollaborator = `-- name: AddHubCollaborator :one
INSERT INTO collaborators (user_id, resource_type, resource_id, role)
VALUES ($1, 'hub', $2, $3)
RETURNING id, user_id, resource_type, resource_id, role, invited_at, accepted_at
`

type AddHubCollaboratorParams struct {
	UserID     int32            `json:"user_id"`
	ResourceID int32            `json:"resource_id"`
	Role       CollaboratorRole `json:"role"`
}

func (q *Queries) AddHubCollaborator(ctx context.Context, arg AddHubCollaboratorParams) (Collaborator, error) {
	row := q.db.QueryRow(ctx, addHubCollaborator, arg.UserID, arg.ResourceID, arg.Role)
	var i Collaborator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceType,
		&i.ResourceID,
		&i.Role,
		&i.InvitedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const createHub = `-- name: CreateHub :one
INSERT INTO hubs (user_id, name, description, visibility)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, name, description, visibility, created_at, updated_at
`

type CreateHubParams struct {
	UserID      int32          `json:"user_id"`
	Name        string         `json:"name"`
	Description pgtype.Text    `json:"description"`
	Visibility  VisibilityType `json:"visibility"`
}

func (q *Queries) CreateHub(ctx context.Context, arg CreateHubParams) (Hub, error) {
	row := q.db.QueryRow(ctx, createHub,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Visibility,
	)
	var i Hub
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Visibility,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteHub = `-- name: DeleteHub :exec
DELETE FROM hubs
WHERE id = $1 AND user_id = $2
`

type DeleteHubParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteHub(ctx context.Context, arg DeleteHubParams) error {
	_, err := q.db.Exec(ctx, deleteHub, arg.ID, arg.UserID)
	return err
}

const getHub = `-- name: GetHub :one
SELECT id, user_id, name, description, visibility, created_at, updated_at FROM hubs
WHERE id = $1 AND user_id = $2
`

type GetHubParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetHub(ctx context.Context, arg GetHubParams) (Hub, error) {
	row := q.db.QueryRow(ctx, getHub, arg.ID, arg.UserID)
	var i Hub
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Visibility,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHubCollaborators = `-- name: GetHubCollaborators :many
SELECT u.id, u.username, u.email, c.role
FROM collaborators c
JOIN users u ON u.id = c.user_id
WHERE c.resource_type = 'hub' AND c.resource_id = $1
`

type GetHubCollaboratorsRow struct {
	ID       int32            `json:"id"`
	Username string           `json:"username"`
	Email    string           `json:"email"`
	Role     CollaboratorRole `json:"role"`
}

func (q *Queries) GetHubCollaborators(ctx context.Context, resourceID int32) ([]GetHubCollaboratorsRow, error) {
	rows, err := q.db.Query(ctx, getHubCollaborators, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHubCollaboratorsRow
	for rows.Next() {
		var i GetHubCollaboratorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHubSources = `-- name: GetHubSources :many
SELECT DISTINCT s.id, s.user_id, s.title, s.url, s.author, s.publication_date, s.content, s.created_at, s.updated_at
FROM hubs h
JOIN trails t ON t.user_id = h.user_id
JOIN trail_notes tn ON tn.trail_id = t.id
JOIN notes n ON n.id = tn.note_id
JOIN note_sources ns ON ns.note_id = n.id
JOIN sources s ON s.id = ns.source_id
WHERE h.id = $1 AND h.user_id = $2
ORDER BY s.created_at DESC
`

type GetHubSourcesParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetHubSources(ctx context.Context, arg GetHubSourcesParams) ([]Source, error) {
	rows, err := q.db.Query(ctx, getHubSources, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Source
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Author,
			&i.PublicationDate,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHubStats = `-- name: GetHubStats :one
SELECT 
    COUNT(DISTINCT t.id) AS trail_count,
    COUNT(DISTINCT n.id) AS note_count,
    COUNT(DISTINCT s.id) AS source_count
FROM hubs h
LEFT JOIN trails t ON t.user_id = h.user_id
LEFT JOIN trail_notes tn ON tn.trail_id = t.id
LEFT JOIN notes n ON n.id = tn.note_id
LEFT JOIN note_sources ns ON ns.note_id = n.id
LEFT JOIN sources s ON s.id = ns.source_id
WHERE h.id = $1 AND h.user_id = $2
`

type GetHubStatsParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

type GetHubStatsRow struct {
	TrailCount  int64 `json:"trail_count"`
	NoteCount   int64 `json:"note_count"`
	SourceCount int64 `json:"source_count"`
}

func (q *Queries) GetHubStats(ctx context.Context, arg GetHubStatsParams) (GetHubStatsRow, error) {
	row := q.db.QueryRow(ctx, getHubStats, arg.ID, arg.UserID)
	var i GetHubStatsRow
	err := row.Scan(&i.TrailCount, &i.NoteCount, &i.SourceCount)
	return i, err
}

const getHubWithTrailsNotesAndSources = `-- name: GetHubWithTrailsNotesAndSources :one
SELECT 
    h.id AS hub_id,
    h.name AS hub_name,
    h.description AS hub_description,
    h.visibility AS hub_visibility,
    h.created_at AS hub_created_at,
    h.updated_at AS hub_updated_at,
    json_agg(DISTINCT jsonb_build_object(
        'id', t.id,
        'title', t.title,
        'description', t.description,
        'visibility', t.visibility,
        'created_at', t.created_at,
        'updated_at', t.updated_at,
        'notes', (
            SELECT json_agg(jsonb_build_object(
                'id', n.id,
                'title', n.title,
                'content', n.content,
                'created_at', n.created_at,
                'updated_at', n.updated_at,
                'position', tn.position,
                'tags', (
                    SELECT string_agg(tg.name, ',')
                    FROM note_tags nt
                    JOIN tags tg ON tg.id = nt.tag_id
                    WHERE nt.note_id = n.id
                ),
                'sources', (
                    SELECT json_agg(jsonb_build_object(
                        'id', s.id,
                        'title', s.title,
                        'url', s.url,
                        'author', s.author,
                        'publication_date', s.publication_date
                    ))
                    FROM note_sources ns
                    JOIN sources s ON s.id = ns.source_id
                    WHERE ns.note_id = n.id
                )
            ))
            FROM trail_notes tn
            JOIN notes n ON n.id = tn.note_id
            WHERE tn.trail_id = t.id
            ORDER BY tn.position
        )
    )) FILTER (WHERE t.id IS NOT NULL) AS trails
FROM hubs h
LEFT JOIN trails t ON t.user_id = h.user_id
WHERE h.id = $1 AND h.user_id = $2
GROUP BY h.id
`

type GetHubWithTrailsNotesAndSourcesParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

type GetHubWithTrailsNotesAndSourcesRow struct {
	HubID          int32              `json:"hub_id"`
	HubName        string             `json:"hub_name"`
	HubDescription pgtype.Text        `json:"hub_description"`
	HubVisibility  VisibilityType     `json:"hub_visibility"`
	HubCreatedAt   pgtype.Timestamptz `json:"hub_created_at"`
	HubUpdatedAt   pgtype.Timestamptz `json:"hub_updated_at"`
	Trails         []byte             `json:"trails"`
}

func (q *Queries) GetHubWithTrailsNotesAndSources(ctx context.Context, arg GetHubWithTrailsNotesAndSourcesParams) (GetHubWithTrailsNotesAndSourcesRow, error) {
	row := q.db.QueryRow(ctx, getHubWithTrailsNotesAndSources, arg.ID, arg.UserID)
	var i GetHubWithTrailsNotesAndSourcesRow
	err := row.Scan(
		&i.HubID,
		&i.HubName,
		&i.HubDescription,
		&i.HubVisibility,
		&i.HubCreatedAt,
		&i.HubUpdatedAt,
		&i.Trails,
	)
	return i, err
}

const listHubs = `-- name: ListHubs :many
SELECT id, user_id, name, description, visibility, created_at, updated_at FROM hubs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListHubsParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListHubs(ctx context.Context, arg ListHubsParams) ([]Hub, error) {
	rows, err := q.db.Query(ctx, listHubs, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hub
	for rows.Next() {
		var i Hub
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Visibility,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeHubCollaborator = `-- name: RemoveHubCollaborator :exec
DELETE FROM collaborators
WHERE user_id = $1 AND resource_type = 'hub' AND resource_id = $2
`

type RemoveHubCollaboratorParams struct {
	UserID     int32 `json:"user_id"`
	ResourceID int32 `json:"resource_id"`
}

func (q *Queries) RemoveHubCollaborator(ctx context.Context, arg RemoveHubCollaboratorParams) error {
	_, err := q.db.Exec(ctx, removeHubCollaborator, arg.UserID, arg.ResourceID)
	return err
}

const searchHubs = `-- name: SearchHubs :many
SELECT id, user_id, name, description, visibility, created_at, updated_at FROM hubs
WHERE user_id = $1
  AND (name ILIKE '%' || $2 || '%' OR description ILIKE '%' || $2 || '%')
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchHubsParams struct {
	UserID  int32       `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchHubs(ctx context.Context, arg SearchHubsParams) ([]Hub, error) {
	rows, err := q.db.Query(ctx, searchHubs,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hub
	for rows.Next() {
		var i Hub
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Visibility,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHub = `-- name: UpdateHub :one
UPDATE hubs
SET name = $2, description = $3, visibility = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND user_id = $5
RETURNING id, user_id, name, description, visibility, created_at, updated_at
`

type UpdateHubParams struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Description pgtype.Text    `json:"description"`
	Visibility  VisibilityType `json:"visibility"`
	UserID      int32          `json:"user_id"`
}

func (q *Queries) UpdateHub(ctx context.Context, arg UpdateHubParams) (Hub, error) {
	row := q.db.QueryRow(ctx, updateHub,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Visibility,
		arg.UserID,
	)
	var i Hub
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Visibility,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
